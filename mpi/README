
Γαρμπής Παναγιώτης-Ορέστης
Γκαραγκάνης Ευάγγελος
Κοτρώνης Κωνσταντίνος


-Η υλοποίηση του προγράμματος που ζητείται σε MPI είναι πλήρης, και στον συγκεκριμένο φάκελο δίνονται: το βασικό αρχείο με την main,
 το gol-mpi.c, τα αρχεία functions.c και functions.h (που περιέχουν τις συναρτήσεις υπολογισμού της τιμής των κελιών, της εμφάνισης
 των αποτελεσμάτων και κάποιων δεσμεύσεων μνήμης), ένα σειριακό πρόγραμμα για εξακρίβωση της ορθότητας των αποτελεσμάτων, αλλά και
 ένα makefile. Επίσης υπάρχει και ένας φάκελος με αρχεία εισόδου για το πρόγραμμα, με συγκεκριμένα μοτίβα (πχ boat, glider κλπ.),
 τα οποία περιέχουν τις θέσεις συντεταγμένων των ενεργών αρχικών κελιών. Προτείνεται η εξακρίβωση της ορθότητας των υπολογισμών με
 είσοδο το glider σε πίνακα 16χ16, τόσο στο gol-serial (σειριακό), όσο και στο gol-mpi.

-Μία προτεινόμενη είσοδος για το σειριακό πρόγραμμα είναι η εξής: ./gol-serial -n 16 -g 15 -i ./"Input Files"/glider -o2, ενώ μία
 αντίστοιχη είσοδος για το πρόγραμμα της MPI: mpiexec (-f machines) -n 4 ./gol-mpi -n 16 -g 15 -i ./"Input Files"/glider -o2 -d 0.
 Τα ορίσματα επιτελούν τις εξής λειτουργίες: Το -n είναι η διάσταση της πλευράς του τετραγωνικού πίνακα, εδώ δηλαδή πίνακας 16χ16
 (αν δεν μπει το όρισμα, ως default έχουμε πίνακα 8χ8). Το -g είναι οι γεννεές, εδώ δηλαδή 15 (default 3 γεννεές). Το -i για το αρχείο
 που θα διαβαστεί ως είσοδος (οι συντεταγμένες του μοτίβου δηλαδή στον πίνακα). Αν δεν βάλουμε το όρισμα, ή βάλουμε αρχείο που δεν
 υφίσταται, τότε ο πίνακας θα αρχικοποιηθεί με τυχαίες τιμές (0 ή 1). Το -o2 χρησιμοποιείται για εκτύπωση του πίνακα σε κάθε γενεά.
 Αν βάλουμε αντ' αυτού -o1, τότε θα εκτυπωθεί στο τερματικό μόνο η μορφή του τελικού πίνακα (τελευταία γενεά), ενώ αν δεν βάλουμε κανένα,
 το πρόγραμμα έχει ως default να μην εκτυπώνεται ο πίνακας (προφανώς στις μετρήσεις δεν πρέπει μπαίνει σημαία εκτύπωσης, όπως και αν είναι
 μεγάλοι οι πίνακες!). Τέλος, το όρισμα -d χρησιμοποιείται για έλεγχο τερματισμού (δηλαδή αν ο πίνακας παραμένει ο ίδιος σε κάθε γενεά ή
 γίνεται μηδενικός). Ως προεπιλογή το πρόγραμμα δεν χρησιμοποιεί έλεγχο, αλλά αν θελήσουμε να ελέγχουμε ανά 10 γενεές τότε βάζουμε την
 σημαία -d 1. (Αν όντως η συνθήκη τερματισμού είναι αληθής, τότε το πρόγραμμα τερματίζεται - προτείνεται ο έλεγχος με το αρχείο boat).

-Όταν ξεκινάει το πρόγραμμα, αρχικοποιούνται οι διεργασίες της MPI, διαβάζονται τα ορίσματα και αρχικοποιείται ο πίνακας (με τυχαίες ή
 ορισμένες από αρχείο τιμές). Έπειτα ελέγχεται αν ο αριθμός των διεργασιών είναι τετράγωνο ενός φυσικού ακεραίου, ώστε να μπορεί να
 γίνει ορθά η διαμέριση του πίνακα σε blocks και αυτός να διαχωριστεί από την κύρια στις υπόλοιπες διεργασίες. Αν δεν ισχύει αυτό, το
 πρόγραμμα τερματίζει (απαιτούνται ως τιμές διεργασιών οι 1,4,9,16,25 κλπ). Επίσης, αρχικοποιείται το ρολόι για την μέτρηση του χρόνου
 λειτουργίας του προγράμματος, καθώς επίσης αρχικοποιείται δυναμικά και ο υποπίνακας blocks, με διαστάσεις τις απαιτούμενες για τον
 ισόμορφο διαχωρισμό των blocks (Μέγεθος πλευράς / ρίζα διεργασιών = μέγεθος πλευράς του block). Προφανώς όλα αυτά συμβαίνουν σε κάθε
 διεργασία αντίστοιχα και στην αντίστοιχη κατανεμημένη μνήμη της.

-Έπειτα, δημιουργούμε έναν τύπο για τον δυσδιάστατο υποπίνακα, μέσω της MPI_Type_create_subarray(), ώστε η αρχική διεργασία να στείλει
 ακριβώς τον υποπίνακα που απαιτείται στην σωστή διεργασία. Αυτό το πετυχαίνουμε με την MPI_Scatterv(), όπου και διαμοιράζουμε τον αρχικό
 πίνακα στις υπόλοιπες διεργασίες. Στέλνουμε από 1 (counts) υποπίνακα (subarraytype) σε κάθε διεγασία, του οποίου το indexing πετυχαίνουμε
 μέσω του πίνακα starting_point, όπου και υπολογίζουμε σε ποια θέση του αρχικού πίνακα πρέπει να ξεκινάει ο αντίστοιχος υποπίνακας της
 κάθε διεγασίας, οπότε και μετά αυτομάτως με την scatterv παίρνει το κομμάτι που αντιστοιχεί στον τύπο subarraytype. Η θέση αυτή βρίσκεται
 εύκολα, αφού κατά την δέσμευση μνήμης του μεγάλου δυσδιάστατου πίνακα cells (αλλά και του μικρότερου υποπίνακα blocks), οι θέσεις μνήμης
 φροντίσαμε να είναι συνεχόμενες (βλέπε συνάρτηση allocateArray() στο αρχείο functions.c). Γενικότερα, όλοι οι δισδιάστατοι πίνακες που
 χρησιμοποιούνται στο πρόγραμμα είναι με αυτόν τον τρόπο ορισμένοι. Για οικονομία μνήμης, αλλά και μεταφορά μικρότερων δεδομένων μεταξύ
 των διεργασιών, όλοι οι πίνακες είναι τύπου char (άλλωστε οι τιμές του είναι 0 ή 1).

-Αμέσως μετά ορίζουμε τις καρτεσιανές συντεταγμένες μεταξύ των διεργασιών, ώστε να υπολογίσουμε ποιοι είναι οι γειτονικοί πίνακες κατά
 την επικοινωνία τους σε κάθε εξέλιξη γενεάς. Αυτό το πετυχαίνουμε με τις συναρτήσεις MPI_Cart_create() και MPI_Cart_coords(), οπότε και
 αντιστοιχίζουμε στις μεταβλητές upleft, up, upright κλπ. τα νούμερα των αντίστοιχων γειτονικών διεργασιών. Η MPI_Cart_create() έχει την
 δυνατότητα να θεωρήσει τον συνολικό πίνακα διεργασιών ως δυσδιάστατο και περιοδικό στις πλευρές που θέλουμε, κάτι που εκμεταλλευόμαστε
 για εύκολη εύρεση γειτονικών υποπινάκων, σε οποιαδήποτε θέση κι αν αυτοί βρίσκονται.

-Στην συνέχεια, πρέπει να ξεκινήσει η εξέλιξη των γεννεών, οπότε και το συνολικό "παρε δώσε" μεταξύ των διεργασιών. Αρχικά ορίζουμε 2
 πίνακες: Τον neighbor_border, ο οποίος χρησιμοποιείται για να αποσταλεί η τιμή της σειράς ή στήλης που θέλουμε να στείλουμε στην γειτονική
 διεγασία που μας ενδιαφέρει (για παράδειγμα στον από πάνω πίνακα (διεργασία) στέλνουμε την πάνω μας σειρά, ή στον πάνω δεξιά στέλνουμε
 το πάνω δεξιά στοιχείο). Ο δεύτερος πίνακας είναι ο received_border, ένας δισδιάστατος πίνακας που λαμβάνει τα στοιχεία που στάλθηκαν από
 τις γειτονικές διεργασίες, και σε κάθε μία από τις 8 σειρές του (SideBlocks στήλες), λαμβάνει τα στοιχεία των αντίστοιχων γειτόνων (0 κάτω
 δεξιά, 1 από κάτω κλπ.). Αν είναι πλευρά λαμβάνει SideBlocks (μεγεθος πλευράς υποπίνακα) στοιχεία, αλλιώς αν είναι γωνιακό, λαμβάνει μόνο
 ένα στοιχείο char (άλλωστε τόσα στέλνουν και οι αντίστοιχες διεργασίες στους κατάλληλους γείτονες - είτε SideBlocks στοιχεία, είτε 1).

-Οι παραπάνω ανταλλαγές μηνυμάτων γίνονται με τις MPI_Isend και MPI_Irecv, ούτως ώστε να μην περιμένει η διεργασία χωρίς να κάνει τίποτα
 άλλο. Έχει μπει και το waitall ώστε να αποφευχθεί το να χαθούν μηνύματα, ενώ επίσης έχει μπει και MPI_Barrier, ώστε να είναι βέβαιο ότι όλες
 οι διεργασίες έχουν τελειώσει την επικοινωνία μεταξύ τους στην ίδια γεννεά. Αυτό γίνεται καθώς αν μία διεργασία προχωρήσει στην επόμενη 
 γεννεά, είναι πιθανό το μήνυμα που θα στείλει στις γειτονικές διεργασίες, αυτές να το θεωρήσουν ως μήνυμα της προηγούμενης γεννεάς, οπότε
 και να χαθεί ένα μήνυμα. Αν και στο μάθημα είχε ειπωθεί ότι δεν πρέπει να μπει MPI_Barrier, αυτό είναι λάθος, καθώς οι γεννές πρέπει για
 τον παραπάνω λόγο να εξελίσσονται ταυτόχρονα. Δοκιμές στο πρόγραμμα μπορούν να το επιβεβαιώσουν (αν βγάλετε το MPI_Barrier και βάλετε την
 σημαία -o2, τότε θα δείτε πως όντως η εξέλιξη είναι λανθασμένη). Μέχρι να ολοκληρωθούν οι isend και irecv, μέσω της συνάρτησης evolve_inner()
 εξελίσσουμε τα εσωτερικά κελιά του υποπίνακα, ενώ αφότου τελειώσουν οι συναλλαγές μηνυμάτων, εξελίσσουμε και τα κελιά των πλευρών. Εξετάζουμε
 το κάθε ακριανό κελί με τα γειτονικά του εσωτερικά αλλά και εξωτερικά των άλλων υποπινάκων, οι τιμές των οποίων βρίσκονται στον πίνακα
 received_border που περιγράψαμε από πάνω. Τελικά γίνεται η αντιγραφή των νέων στοιχείων στον παλιό πίνακα μέσω ανάθεσης δεικτών (*swap).

-Κατά την εξέλιξη των κελιών, βλέπουμε και κατά πόσον αυτά έχουν παραμείνει στάσιμα ή όλα είναι μηδενικά (μεταβλητές allzero, change). Αν
 έχουμε εισαγάγει την σημαία -d 1, δηλαδή θέλουμε να κάνουμε έλεγχο τερματισμό, κοιτάζουμε μέσω της MPI_Reduce την μέγιστη τιμή των μεταβλητών
 allzero και change. Αν έστω και μία από αυτές τις μέγιστες τιμές βγει 1, σημαίνει είτε ότι δεν υπήρξε αλλαγή είτε ότι όλα τα κελιά είναι
 μηδενικά (σε αντίθετη περίπτωση θα ήταν όλα 0, οπότε και το max θα ήταν 0). Έτσι, αν ισχύει κάποια συνθήκη τερματισμού, το
 πρόγραμμα σταματάει.

-Αν έχει προστεθεί το όρισμα -o2 στην γραμμή εντολών, τότε σε κάθε γεννεά με την MPI_Gatherv ο μεγάλος πίνακας συνεννόνεται από τους υποπίνακές
 του και εκτυπώνεται το αποτέλεσμα, αλλιώς αυτό συμβαίνει μόνο κατά τον τερματισμών όλων των γεννεών (προαιρετική η εκτύπωση με -o1). Τελικά,
 ότι έχει δεσμευτεί δυναμικά ελευθερώνεται, ενώ εκτυπώνεται και ο συνολικός μέσος χρόνος όλων των διεργασιών του προγράμματος.

-Στον κώδικα υπάρχουν αναλυτικά σχόλια για περαιτέρω διευκρινίσεις.





